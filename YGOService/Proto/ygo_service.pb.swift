// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ygo_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Ygo_CardColors: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var values: Dictionary<String,UInt32> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ygo_Card: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var color: String = String()

  var name: String = String()

  var attribute: String = String()

  var effect: String = String()

  var monsterType: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _monsterType ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_monsterType = newValue}
  }
  /// Returns true if `monsterType` has been explicitly set.
  var hasMonsterType: Bool {return self._monsterType != nil}
  /// Clears the value of `monsterType`. Subsequent reads from it will return its default value.
  mutating func clearMonsterType() {self._monsterType = nil}

  var attack: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _attack ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_attack = newValue}
  }
  /// Returns true if `attack` has been explicitly set.
  var hasAttack: Bool {return self._attack != nil}
  /// Clears the value of `attack`. Subsequent reads from it will return its default value.
  mutating func clearAttack() {self._attack = nil}

  var defense: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _defense ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_defense = newValue}
  }
  /// Returns true if `defense` has been explicitly set.
  var hasDefense: Bool {return self._defense != nil}
  /// Clears the value of `defense`. Subsequent reads from it will return its default value.
  mutating func clearDefense() {self._defense = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _monsterType: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _attack: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _defense: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

struct Ygo_Cards: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cardInfo: Dictionary<String,Ygo_Card> = [:]

  var unknownResources: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ygo_CardList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cards: [Ygo_Card] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ygo_Product: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var locale: String = String()

  var name: String = String()

  var type: String = String()

  var subType: String = String()

  var releaseDate: String = String()

  var totalItems: UInt32 = 0

  var items: [Ygo_ProductItem] = []

  var rarityDistribution: Dictionary<String,UInt32> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ygo_ProductItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var card: Ygo_Card {
    get {return _card ?? Ygo_Card()}
    set {_card = newValue}
  }
  /// Returns true if `card` has been explicitly set.
  var hasCard: Bool {return self._card != nil}
  /// Clears the value of `card`. Subsequent reads from it will return its default value.
  mutating func clearCard() {self._card = nil}

  var position: String = String()

  var rarities: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _card: Ygo_Card? = nil
}

struct Ygo_ProductSummary: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var locale: String = String()

  var name: String = String()

  var type: String = String()

  var subType: String = String()

  var releaseDate: String = String()

  var totalItems: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ygo_Products: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var products: Dictionary<String,Ygo_ProductSummary> = [:]

  var unknownResources: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ygo_Format: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ygo_RestrictedContentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var format: String = String()

  var effectiveDate: String = String()

  var sortOrder: Ygo_Common_CardRestrictionSortOrder = .cardName

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ygo_ScoresForFormatAndDate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var format: String = String()

  var effectiveDate: String = String()

  var nextFormatDate: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _nextFormatDate ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_nextFormatDate = newValue}
  }
  /// Returns true if `nextFormatDate` has been explicitly set.
  var hasNextFormatDate: Bool {return self._nextFormatDate != nil}
  /// Clears the value of `nextFormatDate`. Subsequent reads from it will return its default value.
  mutating func clearNextFormatDate() {self._nextFormatDate = nil}

  var previousFormatDate: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _previousFormatDate ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_previousFormatDate = newValue}
  }
  /// Returns true if `previousFormatDate` has been explicitly set.
  var hasPreviousFormatDate: Bool {return self._previousFormatDate != nil}
  /// Clears the value of `previousFormatDate`. Subsequent reads from it will return its default value.
  mutating func clearPreviousFormatDate() {self._previousFormatDate = nil}

  var entries: [Ygo_CardScoreEntry] = []

  var totalEntries: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nextFormatDate: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _previousFormatDate: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

struct Ygo_CardScoreEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var card: Ygo_Card {
    get {return _card ?? Ygo_Card()}
    set {_card = newValue}
  }
  /// Returns true if `card` has been explicitly set.
  var hasCard: Bool {return self._card != nil}
  /// Clears the value of `card`. Subsequent reads from it will return its default value.
  mutating func clearCard() {self._card = nil}

  var score: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _card: Ygo_Card? = nil
}

struct Ygo_CardScore: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentScoreByFormat: Dictionary<String,UInt32> = [:]

  var uniqueFormats: [String] = []

  var scoreHistory: [Ygo_ScoreEntry] = []

  var scheduledChanges: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ygo_CardScores: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cardInfo: Dictionary<String,Ygo_CardScore> = [:]

  var unknownResources: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ygo_ScoreEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var format: String = String()

  var effectiveDate: String = String()

  var score: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ygo"

extension Ygo_CardColors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CardColors"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}values\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_CardColors, rhs: Ygo_CardColors) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_Card: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Card"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ID\0\u{1}color\0\u{1}name\0\u{1}attribute\0\u{1}effect\0\u{3}monster_type\0\u{1}attack\0\u{1}defense\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.color) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.attribute) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.effect) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._monsterType) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._attack) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._defense) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.attribute.isEmpty {
      try visitor.visitSingularStringField(value: self.attribute, fieldNumber: 4)
    }
    if !self.effect.isEmpty {
      try visitor.visitSingularStringField(value: self.effect, fieldNumber: 5)
    }
    try { if let v = self._monsterType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._attack {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._defense {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_Card, rhs: Ygo_Card) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.color != rhs.color {return false}
    if lhs.name != rhs.name {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.effect != rhs.effect {return false}
    if lhs._monsterType != rhs._monsterType {return false}
    if lhs._attack != rhs._attack {return false}
    if lhs._defense != rhs._defense {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_Cards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Cards"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}card_info\0\u{3}unknown_resources\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ygo_Card>.self, value: &self.cardInfo) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.unknownResources) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cardInfo.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ygo_Card>.self, value: self.cardInfo, fieldNumber: 1)
    }
    if !self.unknownResources.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unknownResources, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_Cards, rhs: Ygo_Cards) -> Bool {
    if lhs.cardInfo != rhs.cardInfo {return false}
    if lhs.unknownResources != rhs.unknownResources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_CardList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CardList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cards\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cards, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_CardList, rhs: Ygo_CardList) -> Bool {
    if lhs.cards != rhs.cards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_Product: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Product"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ID\0\u{1}locale\0\u{1}name\0\u{1}type\0\u{1}subType\0\u{1}releaseDate\0\u{1}totalItems\0\u{1}items\0\u{1}rarityDistribution\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.locale) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.subType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.releaseDate) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.totalItems) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: &self.rarityDistribution) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.locale.isEmpty {
      try visitor.visitSingularStringField(value: self.locale, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 4)
    }
    if !self.subType.isEmpty {
      try visitor.visitSingularStringField(value: self.subType, fieldNumber: 5)
    }
    if !self.releaseDate.isEmpty {
      try visitor.visitSingularStringField(value: self.releaseDate, fieldNumber: 6)
    }
    if self.totalItems != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalItems, fieldNumber: 7)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 8)
    }
    if !self.rarityDistribution.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: self.rarityDistribution, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_Product, rhs: Ygo_Product) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.locale != rhs.locale {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.subType != rhs.subType {return false}
    if lhs.releaseDate != rhs.releaseDate {return false}
    if lhs.totalItems != rhs.totalItems {return false}
    if lhs.items != rhs.items {return false}
    if lhs.rarityDistribution != rhs.rarityDistribution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_ProductItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProductItem"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}card\0\u{1}position\0\u{1}rarities\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._card) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.position) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.rarities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._card {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.position.isEmpty {
      try visitor.visitSingularStringField(value: self.position, fieldNumber: 2)
    }
    if !self.rarities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rarities, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_ProductItem, rhs: Ygo_ProductItem) -> Bool {
    if lhs._card != rhs._card {return false}
    if lhs.position != rhs.position {return false}
    if lhs.rarities != rhs.rarities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_ProductSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProductSummary"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ID\0\u{1}locale\0\u{1}name\0\u{1}type\0\u{1}subType\0\u{1}releaseDate\0\u{1}totalItems\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.locale) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.subType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.releaseDate) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.totalItems) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.locale.isEmpty {
      try visitor.visitSingularStringField(value: self.locale, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 4)
    }
    if !self.subType.isEmpty {
      try visitor.visitSingularStringField(value: self.subType, fieldNumber: 5)
    }
    if !self.releaseDate.isEmpty {
      try visitor.visitSingularStringField(value: self.releaseDate, fieldNumber: 6)
    }
    if self.totalItems != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalItems, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_ProductSummary, rhs: Ygo_ProductSummary) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.locale != rhs.locale {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.subType != rhs.subType {return false}
    if lhs.releaseDate != rhs.releaseDate {return false}
    if lhs.totalItems != rhs.totalItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_Products: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Products"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}products\0\u{3}unknown_resources\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ygo_ProductSummary>.self, value: &self.products) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.unknownResources) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.products.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ygo_ProductSummary>.self, value: self.products, fieldNumber: 1)
    }
    if !self.unknownResources.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unknownResources, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_Products, rhs: Ygo_Products) -> Bool {
    if lhs.products != rhs.products {return false}
    if lhs.unknownResources != rhs.unknownResources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_Format: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Format"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_Format, rhs: Ygo_Format) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_RestrictedContentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RestrictedContentRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}format\0\u{3}effective_date\0\u{3}sort_order\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.effectiveDate) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.sortOrder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 1)
    }
    if !self.effectiveDate.isEmpty {
      try visitor.visitSingularStringField(value: self.effectiveDate, fieldNumber: 2)
    }
    if self.sortOrder != .cardName {
      try visitor.visitSingularEnumField(value: self.sortOrder, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_RestrictedContentRequest, rhs: Ygo_RestrictedContentRequest) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.effectiveDate != rhs.effectiveDate {return false}
    if lhs.sortOrder != rhs.sortOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_ScoresForFormatAndDate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScoresForFormatAndDate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}format\0\u{3}effective_date\0\u{3}next_format_date\0\u{3}previous_format_date\0\u{1}entries\0\u{3}total_entries\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.effectiveDate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._nextFormatDate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._previousFormatDate) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalEntries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 1)
    }
    if !self.effectiveDate.isEmpty {
      try visitor.visitSingularStringField(value: self.effectiveDate, fieldNumber: 2)
    }
    try { if let v = self._nextFormatDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._previousFormatDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 5)
    }
    if self.totalEntries != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalEntries, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_ScoresForFormatAndDate, rhs: Ygo_ScoresForFormatAndDate) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.effectiveDate != rhs.effectiveDate {return false}
    if lhs._nextFormatDate != rhs._nextFormatDate {return false}
    if lhs._previousFormatDate != rhs._previousFormatDate {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.totalEntries != rhs.totalEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_CardScoreEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CardScoreEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}card\0\u{1}score\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._card) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.score) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._card {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.score != 0 {
      try visitor.visitSingularUInt32Field(value: self.score, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_CardScoreEntry, rhs: Ygo_CardScoreEntry) -> Bool {
    if lhs._card != rhs._card {return false}
    if lhs.score != rhs.score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_CardScore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CardScore"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_score_by_format\0\u{3}unique_formats\0\u{3}score_history\0\u{3}scheduled_changes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: &self.currentScoreByFormat) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.uniqueFormats) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.scoreHistory) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.scheduledChanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currentScoreByFormat.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: self.currentScoreByFormat, fieldNumber: 1)
    }
    if !self.uniqueFormats.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uniqueFormats, fieldNumber: 2)
    }
    if !self.scoreHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scoreHistory, fieldNumber: 3)
    }
    if !self.scheduledChanges.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scheduledChanges, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_CardScore, rhs: Ygo_CardScore) -> Bool {
    if lhs.currentScoreByFormat != rhs.currentScoreByFormat {return false}
    if lhs.uniqueFormats != rhs.uniqueFormats {return false}
    if lhs.scoreHistory != rhs.scoreHistory {return false}
    if lhs.scheduledChanges != rhs.scheduledChanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_CardScores: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CardScores"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}card_info\0\u{3}unknown_resources\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ygo_CardScore>.self, value: &self.cardInfo) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.unknownResources) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cardInfo.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ygo_CardScore>.self, value: self.cardInfo, fieldNumber: 1)
    }
    if !self.unknownResources.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unknownResources, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_CardScores, rhs: Ygo_CardScores) -> Bool {
    if lhs.cardInfo != rhs.cardInfo {return false}
    if lhs.unknownResources != rhs.unknownResources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ygo_ScoreEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScoreEntry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}format\0\u{3}effective_date\0\u{1}score\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.effectiveDate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.score) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 1)
    }
    if !self.effectiveDate.isEmpty {
      try visitor.visitSingularStringField(value: self.effectiveDate, fieldNumber: 2)
    }
    if self.score != 0 {
      try visitor.visitSingularUInt32Field(value: self.score, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ygo_ScoreEntry, rhs: Ygo_ScoreEntry) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.effectiveDate != rhs.effectiveDate {return false}
    if lhs.score != rhs.score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
